<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Railway Network Graph Algorithms</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f9fafb;
      color: #333;
      margin-left: 300px;
    }
    h2 {
      color: #1e40af;
      margin-bottom: 15px;
      margin-left :300px;
    }
    label {
      margin-right: 20px;
      font-weight: 600;
      margin-left: 70px;
    }
    select, button {
      margin-right: 15px;
      padding: 6px 12px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      outline: none;
      transition: border-color 0.2s ease;
      cursor: pointer;
    }
    select:focus, button:focus {
      border-color: #1e40af;
      box-shadow: 0 0 5px rgba(30, 64, 175, 0.5);
    }
    button {
      background-color: #1e40af;
      color: white;
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    button:disabled {
      background-color: #999;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #374abe;
    }
    p#cost {
      font-weight: 700;
      margin-top: 12px;
      font-size: 16px;
      color: #d97706; /* amber-600 */
    }
    svg {
      background: #f4f4f4;
      border: 1px solid #ccc;
      display: block;
      margin-top: 20px;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);
    }
    circle.node {
      fill: #1e40af;
      cursor: pointer;
      transition: fill 0.3s ease;
    }
    circle.node:hover {
      fill: #3b82f6;
    }
    line.edge {
      stroke: #555;
      stroke-width: 2;
      transition: stroke-width 0.3s ease, stroke 0.3s ease;
    }
    line.highlight {
      stroke: orange;
      stroke-width: 4;
    }
    circle.train {
      fill: red;
      stroke: black;
      stroke-width: 1.5;
    }
    text.label {
      font-size: 12px;
      user-select: none;
      pointer-events: none;
      font-weight: 600;
      fill: #222;
    }
    /* Tooltip styling */
    .tooltip {
      position: absolute;
      background-color: #333;
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 10;
    }
    /* Back button style */
    button#backBtn {
      margin-top: 20px;
      background-color: #555;
      border: none;
      padding: 8px 16px;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      font-weight: 600;
    }
    button#backBtn:hover {
      background-color: #333;
    }
  </style>
</head>
<body>
  <h2>Railway Network Graph Algorithms</h2>
  <label for="startNode">Start Node:</label>
  <select id="startNode"></select>
  <label for="endNode">End Node:</label>
  <select id="endNode"></select>
  <label for="algorithm">Algorithm:</label>
  <select id="algorithm">
    <option>Dijkstra</option>
    <option>Bellman-Ford</option>
    <option>Floyd-Warshall</option>
    <option>Prim</option>
    <option>Kruskal</option>
  </select>
  <button id="runBtn" disabled>Run</button>
  <p id="cost"></p>

<svg width="1000" height="700"></svg>

  <div class="tooltip" id="tooltip"></div>

<button id="backBtn">Go Back</button>

  <script>
    const svg = d3.select("svg");
    const tooltip = d3.select("#tooltip");
    const runBtn = document.getElementById("runBtn");
    const startSelect = document.getElementById("startNode");
    const endSelect = document.getElementById("endNode");
    const algorithmSelect = document.getElementById("algorithm");
    const costDisplay = document.getElementById("cost");
    const backBtn = document.getElementById("backBtn");

    const graph = {
      nodes: [
        { id: 'A', x: 100, y: 100 },
        { id: 'B', x: 300, y: 80 },
        { id: 'C', x: 500, y: 120 },
        { id: 'D', x: 700, y: 150 },
        { id: 'E', x: 200, y: 300 },
        { id: 'F', x: 400, y: 280 },
        { id: 'G', x: 600, y: 320 },
        { id: 'H', x: 800, y: 300 }
      ],
      edges: [
        { source: 'A', target: 'B', weight: 4 },
        { source: 'A', target: 'E', weight: 3 },
        { source: 'B', target: 'C', weight: 1 },
        { source: 'B', target: 'F', weight: 7 },
        { source: 'C', target: 'D', weight: 6 },
        { source: 'C', target: 'G', weight: 2 },
        { source: 'D', target: 'H', weight: 5 },
        { source: 'E', target: 'F', weight: 4 },
        { source: 'F', target: 'G', weight: 1 },
        { source: 'G', target: 'H', weight: 3 }
      ]
    };

    const nodeById = Object.fromEntries(graph.nodes.map(n => [n.id, n]));

    // Populate start and end node dropdowns
    function populateDropdowns() {
      graph.nodes.forEach(n => {
        const optionStart = document.createElement("option");
        optionStart.value = n.id;
        optionStart.textContent = n.id;
        startSelect.appendChild(optionStart);

        const optionEnd = document.createElement("option");
        optionEnd.value = n.id;
        optionEnd.textContent = n.id;
        endSelect.appendChild(optionEnd);
      });
      // Set defaults
      startSelect.selectedIndex = 0;
      endSelect.selectedIndex = 1;
      validateSelection();
    }

    // Enable or disable run button based on valid selections
    function validateSelection() {
      if (
        startSelect.value &&
        endSelect.value &&
        startSelect.value !== endSelect.value
      ) {
        runBtn.disabled = false;
      } else {
        runBtn.disabled = true;
        costDisplay.textContent = "";
      }
    }

    startSelect.addEventListener("change", validateSelection);
    endSelect.addEventListener("change", validateSelection);

    // Groups for edges and nodes
    const edgeGroup = svg.append("g").attr("class", "edges");
    const nodeGroup = svg.append("g").attr("class", "nodes");

    // Draw graph with optional highlighted edges
    function drawGraph(highlightedEdges = []) {
      edgeGroup.selectAll("*").remove();
      nodeGroup.selectAll("*").remove();

      // Draw edges
      edgeGroup.selectAll("line")
        .data(graph.edges)
        .enter()
        .append("line")
        .attr("class", d => highlightedEdges.includes(d) ? "edge highlight" : "edge")
        .attr("x1", d => nodeById[d.source].x)
        .attr("y1", d => nodeById[d.source].y)
        .attr("x2", d => nodeById[d.target].x)
        .attr("y2", d => nodeById[d.target].y)
        .on("mousemove", (event, d) => {
          tooltip.style("opacity", 1)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY + 10) + "px")
            .html(`Edge: <strong>${d.source} â†” ${d.target}</strong><br>Weight: ${d.weight}`);
        })
        .on("mouseout", () => tooltip.style("opacity", 0));

      // Edge weight labels
      edgeGroup.selectAll("text")
        .data(graph.edges)
        .enter()
        .append("text")
        .attr("class", "label")
        .attr("x", d => (nodeById[d.source].x + nodeById[d.target].x) / 2)
        .attr("y", d => (nodeById[d.source].y + nodeById[d.target].y) / 2 - 8)
        .text(d => d.weight);

      // Draw nodes
      nodeGroup.selectAll("circle")
        .data(graph.nodes)
        .enter()
        .append("circle")
        .attr("class", "node")
        .attr("r", 12)
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .on("mousemove", (event, d) => {
          tooltip.style("opacity", 1)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY + 10) + "px")
            .html(`Node: <strong>${d.id}</strong>`);
        })
        .on("mouseout", () => tooltip.style("opacity", 0));

      // Node labels
      nodeGroup.selectAll("text")
        .data(graph.nodes)
        .enter()
        .append("text")
        .attr("class", "label")
        .attr("x", d => d.x + 16)
        .attr("y", d => d.y + 5)
        .text(d => d.id);
    }

    // Convert path array to edges array
    function pathToEdges(path) {
      const edges = [];
      for (let i = 0; i < path.length - 1; i++) {
        const from = path[i];
        const to = path[i + 1];
        const edge = graph.edges.find(e => 
          (e.source === from && e.target === to) || (e.source === to && e.target === from));
        if (edge) edges.push(edge);
      }
      return edges;
    }

    // Animate train along path
    function animateTrain(path) {
      svg.selectAll(".train").remove();
      if (!path || path.length < 2) return;

      const train = svg.append("circle").attr("class", "train").attr("r", 10);
      let i = 0;

      function move() {
        if (i < path.length - 1) {
          const from = nodeById[path[i]];
          const to = nodeById[path[i + 1]];
          train.attr("cx", from.x).attr("cy", from.y)
            .transition()
            .duration(1000)
            .attr("cx", to.x)
            .attr("cy", to.y)
            .on("end", () => {
              i++;
              setTimeout(move, 400); // pause 400ms at node
            });
        } else {
          // Animation complete, remove train after short delay
          setTimeout(() => train.remove(), 800);
        }
      }
      move();
    }

    // Run button click handler
    function runAlgorithm() {
      const start = startSelect.value;
      const end = endSelect.value;
      const algorithm = algorithmSelect.value;

      let result;
      if (algorithm === "Dijkstra") result = dijkstra(graph, start, end);
      else if (algorithm === "Bellman-Ford") result = bellmanFord(graph, start, end);
      else if (algorithm === "Floyd-Warshall") result = floydWarshall(graph, start, end);
      else if (algorithm === "Prim") result = prim(graph);
      else if (algorithm === "Kruskal") result = kruskal(graph);

      if (!result) {
        costDisplay.textContent = "Algorithm not implemented or error.";
        drawGraph();
        return;
      }

      // For shortest path algorithms
      if (result.path && result.path.length > 0) {
        animateTrain(result.path);
        drawGraph(result.edges || pathToEdges(result.path));
        costDisplay.textContent = `Total cost: ${result.cost === Infinity ? "No path" : result.cost}`;
      } else if (result.edges) {
        // For MST algorithms (Prim, Kruskal)
        animateTrain(null);
        drawGraph(result.edges);
        costDisplay.textContent = `Total cost: ${result.cost}`;
      } else {
        drawGraph();
        costDisplay.textContent = "No path found.";
      }
    }

    runBtn.addEventListener("click", runAlgorithm);
     algorithmSelect.addEventListener("change", () => {
      // Disable end node selection for Prim and Kruskal (MST algorithms)
      const algo = algorithmSelect.value;
      if (algo === "Prim" || algo === "Kruskal" || algo === "Floyd-Warshall") {
        endSelect.disabled = true;
      } else {
        endSelect.disabled = false;
      }
      validateSelection();
      costDisplay.textContent = "";
      drawGraph();
      svg.selectAll(".train").remove();
    });

    // Initial setup
    populateDropdowns();
    drawGraph();

    // --- Algorithm implementations ---

    // Helper: Get neighbors of a node with weights
    function getNeighbors(nodeId) {
      return graph.edges
        .filter(e => e.source === nodeId || e.target === nodeId)
        .map(e => {
          const neighbor = e.source === nodeId ? e.target : e.source;
          return { node: neighbor, weight: e.weight };
        });
    }

    // Dijkstra's algorithm
    function dijkstra(graph, start, end) {
      const distances = {};
      const prev = {};
      const nodes = new Set(graph.nodes.map(n => n.id));

      graph.nodes.forEach(n => distances[n.id] = Infinity);
      distances[start] = 0;

      while (nodes.size) {
        let current = null;
        nodes.forEach(n => {
          if (current === null || distances[n] < distances[current]) current = n;
        });

        if (distances[current] === Infinity) break;
        if (current === end) break;

        nodes.delete(current);

        getNeighbors(current).forEach(({node, weight}) => {
          if (!nodes.has(node)) return;
          let alt = distances[current] + weight;
          if (alt < distances[node]) {
            distances[node] = alt;
            prev[node] = current;
          }
        });
      }

      // Reconstruct path
      let path = [];
      let u = end;
      if (prev[u] !== undefined || u === start) {
        while (u) {
          path.unshift(u);
          u = prev[u];
        }
      }

      return {
        path,
        cost: distances[end],
        edges: pathToEdges(path)
      };
    }

    // Bellman-Ford algorithm
    function bellmanFord(graph, start, end) {
      const distances = {};
      const prev = {};

      graph.nodes.forEach(n => distances[n.id] = Infinity);
      distances[start] = 0;

      for (let i = 0; i < graph.nodes.length - 1; i++) {
        graph.edges.forEach(({source, target, weight}) => {
          if (distances[source] + weight < distances[target]) {
            distances[target] = distances[source] + weight;
            prev[target] = source;
          }
          if (distances[target] + weight < distances[source]) {
            distances[source] = distances[target] + weight;
            prev[source] = target;
          }
        });
      }

      // Check for negative-weight cycles (optional here)
      for (const {source, target, weight} of graph.edges) {
        if (distances[source] + weight < distances[target]) {
          costDisplay.textContent = "Graph contains a negative-weight cycle.";
          return null;
        }
      }

      // Reconstruct path
      let path = [];
      let u = end;
      if (prev[u] !== undefined || u === start) {
        while (u) {
          path.unshift(u);
          u = prev[u];
        }
      }

      return {
        path,
        cost: distances[end],
        edges: pathToEdges(path)
      };
    }

    // Floyd-Warshall algorithm
    function floydWarshall(graph) {
      const nodes = graph.nodes.map(n => n.id);
      const dist = {};
      const next = {};

      nodes.forEach(i => {
        dist[i] = {};
        next[i] = {};
        nodes.forEach(j => {
          dist[i][j] = i === j ? 0 : Infinity;
          next[i][j] = null;
        });
      });

      graph.edges.forEach(({source, target, weight}) => {
        dist[source][target] = weight;
        dist[target][source] = weight;
        next[source][target] = target;
        next[target][source] = source;
      });

      nodes.forEach(k => {
        nodes.forEach(i => {
          nodes.forEach(j => {
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
              dist[i][j] = dist[i][k] + dist[k][j];
              next[i][j] = next[i][k];
            }
          });
        });
      });

      // Since endSelect disabled for FW, we show all shortest paths or MST
      // Here just highlight all shortest paths between all pairs, or none
      costDisplay.textContent = "Floyd-Warshall shows shortest paths between all nodes.";

      // We can just draw the graph normally, no path animation (complex)
      drawGraph();

      return {};
    }

    // Prim's algorithm for MST
    function prim(graph) {
      const nodes = graph.nodes.map(n => n.id);
      const selected = new Set();
      const edges = [];
      let totalCost = 0;

      selected.add(nodes[0]);

      while (selected.size < nodes.length) {
        let candidate = null;
        let candidateEdge = null;
        graph.edges.forEach(e => {
          const inSelectedSource = selected.has(e.source);
          const inSelectedTarget = selected.has(e.target);

          if ((inSelectedSource && !inSelectedTarget) || (!inSelectedSource && inSelectedTarget)) {
            if (!candidate || e.weight < candidate.weight) {
              candidate = e;
              candidateEdge = e;
            }
          }
        });
        if (!candidate) break;

        edges.push(candidateEdge);
        totalCost += candidateEdge.weight;
        selected.add(candidateEdge.source);
        selected.add(candidateEdge.target);
      }

      return { edges, cost: totalCost };
    }

    // Kruskal's algorithm for MST
    function kruskal(graph) {
      // Union-Find helper functions
      const parent = {};
      function find(u) {
        if (parent[u] === undefined) parent[u] = u;
        if (parent[u] !== u) parent[u] = find(parent[u]);
        return parent[u];
      }
      function union(u, v) {
        const rootU = find(u);
        const rootV = find(v);
        if (rootU !== rootV) {
          parent[rootV] = rootU;
          return true;
        }
        return false;
      }

      const edgesSorted = [...graph.edges].sort((a, b) => a.weight - b.weight);
      const mstEdges = [];
      let totalCost = 0;

      edgesSorted.forEach(e => {
        if (union(e.source, e.target)) {
          mstEdges.push(e);
          totalCost += e.weight;
        }
      });

      return { edges: mstEdges, cost: totalCost };
    }
  </script>
</body>
</html>
